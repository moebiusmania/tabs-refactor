{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@polymer/polymer/lib/utils/boot.js","webpack:///./node_modules/lit-html/lit-html.js","webpack:///./node_modules/lit-html/lib/lit-extended.js","webpack:///./node_modules/@polymer/polymer/lib/utils/mixin.js","webpack:///./node_modules/@polymer/polymer/lib/utils/async.js","webpack:///./node_modules/@polymer/polymer/lib/mixins/properties-changed.js","webpack:///./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js","webpack:///./node_modules/lit-html/lib/shady-render.js","webpack:///./node_modules/@polymer/lit-element/lit-element.js","webpack:///./src/tabs-refactor/tab-content/index.js","webpack:///./src/tabs-refactor/tabs-main/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","window","JSCompiler_renameProperty","prop","obj","templateCaches","Map","TemplateResult","[object Object]","strings","values","type","partCallback","defaultPartCallback","this","length","html","isTextBinding","closing","findTagClose","nodeMarker","marker","template","document","createElement","innerHTML","getHTML","render","result","container","templateFactory","templateCache","undefined","set","Template","getTemplateElement","instance","__templateInstance","_partCallback","update","TemplateInstance","fragment","_clone","removeNodes","firstChild","appendChild","String","Math","random","slice","markerRegex","RegExp","lastAttributeNameRegex","str","close","lastIndexOf","indexOf","TemplatePart","index","rawName","element","parts","content","walker","createTreeWalker","partIndex","nodesToRemove","previousNode","currentNode","nextNode","node","nodeType","hasAttributes","attributes","count","stringForPart","attributeNameInPart","exec","attribute","getNamedItem","stringsForAttributeValue","split","push","removeAttribute","nodeValue","parent","parentNode","lastIndex","textContent","insertBefore","createTextNode","previousSibling","Node","TEXT_NODE","nextSibling","removeChild","getValue","part","isDirective","directiveValue","__litDirective","isPrimitiveValue","AttributePart","size","_previousValues","startIndex","text","v","Array","isArray","Symbol","iterator","t","_equalToPreviousValues","join","_interpolate","setAttribute","NodePart","startNode","endNode","_previousValue","_setText","_setTemplateResult","_setIterable","_setNode","then","_setPromise","clear","_insert","_getTemplate","itemParts","item","itemPart","itemStart","setValue","lastPart","templatePart","Error","getTemplate","_parts","valueIndex","importNode","lit_extended_html","extendedPartCallback","startsWith","eventName","listener","previous","_listener","removeEventListener","addEventListener","endsWith","dedupeId","MixinFunction","__mixinApplications","__mixinSet","dedupingMixin","mixin","mixinApplications","WeakMap","mixinDedupeId","base","baseSet","map","extended","mixinSet","create","microtaskCurrHandle","microtaskLastHandle","microtaskCallbacks","microtaskNodeContent","microtaskNode","MutationObserver","len","cb","e","setTimeout","splice","observe","characterData","microtask","run","callback","handle","idx","PropertiesChanged","superClass","props","proto","_createPropertyAccessor","toLowerCase","readOnly","_addPropertyToAttributeMap","__dataHasAccessor","assign","_definePropertyAccessor","__dataAttributes","attr","constructor","attributeNameForProperty","_getProperty","_setProperty","super","__dataEnabled","__dataReady","__dataInvalid","__data","__dataPending","__dataOld","__dataInstanceProps","__serializing","_initializeProperties","_flushProperties","_setPendingProperty","_invalidateProperties","ext","old","changed","_shouldPropertyChange","_initializeInstanceProperties","ready","changedProps","_shouldPropertiesChange","_propertiesChanged","currentProps","oldProps","Boolean","namespace","_attributeToProperty","attributeChangedCallback","_deserializeValue","typeForProperty","arguments","_valueToNodeAttribute","_serializeValue","toString","Number","properties_mixin_PropertiesMixin","superPropertiesClass","superCtor","getPrototypeOf","PropertiesMixin","ownProperties","properties","output","normalizeProperties","__ownProperties","observedAttributes","_properties","keys","finalize","__finalized","_finalizeClass","createProperties","__properties","info","connectedCallback","_enableProperties","disconnectedCallback","shadyTemplateFactory","scopeName","cacheKey","ShadyCSS","prepareTemplate","lit_element_LitElement","HTMLElement","__renderComplete","__resolveRenderComplete","__isInvalid","__isChanging","_root","_createRoot","_firstRendered","attachShadow","mode","_props","_changedProps","_prevProps","shouldRender","_shouldRender","prevProps","_render","_applyRender","_didRender","change","console","trace","shady_render_render","localName","renderComplete","Promise","resolve","tab_content_TabContent","is","visible","customElements","define","tabs_main_TabsMain","labels","pills","vertical","centered","fullWidth","active","evt","preventDefault","parseInt","currentTarget","dataset","_setActive","querySelectorAll","forEach","dispatchEvent","CustomEvent","bubbles","composed","detail","arr","_labels","JSON","parse","_computeType","_computeActive","_activateThis"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nwindow.JSCompiler_renameProperty = function(prop, obj) { return prop; }\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nexport const templateCaches = new Map();\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html');\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg');\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, partCallback = defaultPartCallback) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.partCallback = partCallback;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            // We're in a text position if the previous string closed its tags.\n            // If it doesn't have any tags, then we use the previous text position\n            // state.\n            const closing = findTagClose(s);\n            isTextBinding = closing > -1 ? closing < s.length : isTextBinding;\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an <svg> tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the <svg> tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function defaultTemplateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param templateFactory a function to create a Template or retreive one from\n *     cache.\n */\nexport function render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = container.__templateInstance;\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template &&\n        instance._partCallback === result.partCallback) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance =\n        new TemplateInstance(template, result.partCallback, templateFactory);\n    container.__templateInstance = instance;\n    const fragment = instance._clone();\n    instance.update(result.values);\n    removeNodes(container, container.firstChild);\n    container.appendChild(fragment);\n}\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-posisitions, not attribute positions,\n * in template.\n */\nconst nodeMarker = `<!--${marker}-->`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = /[ \\x09\\x0a\\x0c\\x0d]([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)[ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*)$/;\n/**\n * Finds the closing index of the last closed HTML tag.\n * This has 3 possible return values:\n *   - `-1`, meaning there is no tag in str.\n *   - `string.length`, meaning the last opened tag is unclosed.\n *   - Some positive number < str.length, meaning the index of the closing '>'.\n */\nfunction findTagClose(str) {\n    const close = str.lastIndexOf('>');\n    const open = str.indexOf('<', close + 1);\n    return open > -1 ? str.length : close;\n}\n/**\n * A placeholder for a dynamic expression in an HTML template.\n *\n * There are two built-in part types: AttributePart and NodePart. NodeParts\n * always represent a single dynamic expression, while AttributeParts may\n * represent as many expressions are contained in the attribute.\n *\n * A Template's parts are mutable, so parts can be replaced or modified\n * (possibly to implement different template semantics). The contract is that\n * parts can only be replaced, not removed, added or reordered, and parts must\n * always consume the correct number of values in their `update()` method.\n *\n * TODO(justinfagnani): That requirement is a little fragile. A\n * TemplateInstance could instead be more careful about which values it gives\n * to Part.update().\n */\nexport class TemplatePart {\n    constructor(type, index, name, rawName, strings) {\n        this.type = type;\n        this.index = index;\n        this.name = name;\n        this.rawName = rawName;\n        this.strings = strings;\n    }\n}\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const content = this.element.content;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n               NodeFilter.SHOW_TEXT */, null, false);\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        // The actual previous node, accounting for removals: if a node is removed\n        // it will never be the previousNode.\n        let previousNode;\n        // Used to set previousNode at the top of the loop.\n        let currentNode;\n        while (walker.nextNode()) {\n            index++;\n            previousNode = currentNode;\n            const node = currentNode = walker.currentNode;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (!node.hasAttributes()) {\n                    continue;\n                }\n                const attributes = node.attributes;\n                // Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                // attributes are not guaranteed to be returned in document order. In\n                // particular, Edge/IE can return them out of order, so we cannot assume\n                // a correspondance between part index and attribute index.\n                let count = 0;\n                for (let i = 0; i < attributes.length; i++) {\n                    if (attributes[i].value.indexOf(marker) >= 0) {\n                        count++;\n                    }\n                }\n                while (count-- > 0) {\n                    // Get the template literal section leading up to the first\n                    // expression in this attribute attribute\n                    const stringForPart = result.strings[partIndex];\n                    // Find the attribute name\n                    const attributeNameInPart = lastAttributeNameRegex.exec(stringForPart)[1];\n                    // Find the corresponding attribute\n                    const attribute = attributes.getNamedItem(attributeNameInPart);\n                    const stringsForAttributeValue = attribute.value.split(markerRegex);\n                    this.parts.push(new TemplatePart('attribute', index, attribute.name, attributeNameInPart, stringsForAttributeValue));\n                    node.removeAttribute(attribute.name);\n                    partIndex += stringsForAttributeValue.length - 1;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const nodeValue = node.nodeValue;\n                if (nodeValue.indexOf(marker) < 0) {\n                    continue;\n                }\n                const parent = node.parentNode;\n                const strings = nodeValue.split(markerRegex);\n                const lastIndex = strings.length - 1;\n                // We have a part for each match found\n                partIndex += lastIndex;\n                // We keep this current node, but reset its content to the last\n                // literal part. We insert new literal nodes before this so that the\n                // tree walker keeps its position correctly.\n                node.textContent = strings[lastIndex];\n                // Generate a new text node for each literal section\n                // These nodes are also used as the markers for node parts\n                for (let i = 0; i < lastIndex; i++) {\n                    parent.insertBefore(document.createTextNode(strings[i]), node);\n                    this.parts.push(new TemplatePart('node', index++));\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&\n                node.nodeValue === marker) {\n                const parent = node.parentNode;\n                // Add a new marker node to be the startNode of the Part if any of the\n                // following are true:\n                //  * We don't have a previousSibling\n                //  * previousSibling is being removed (thus it's not the\n                //    `previousNode`)\n                //  * previousSibling is not a Text node\n                //\n                // TODO(justinfagnani): We should be able to use the previousNode here\n                // as the marker node and reduce the number of extra nodes we add to a\n                // template. See https://github.com/PolymerLabs/lit-html/issues/147\n                const previousSibling = node.previousSibling;\n                if (previousSibling === null || previousSibling !== previousNode ||\n                    previousSibling.nodeType !== Node.TEXT_NODE) {\n                    parent.insertBefore(document.createTextNode(''), node);\n                }\n                else {\n                    index--;\n                }\n                this.parts.push(new TemplatePart('node', index++));\n                nodesToRemove.push(node);\n                // If we don't have a nextSibling add a marker node.\n                // We don't have to check if the next node is going to be removed,\n                // because that node will induce a new marker if so.\n                if (node.nextSibling === null) {\n                    parent.insertBefore(document.createTextNode(''), node);\n                }\n                else {\n                    index--;\n                }\n                currentNode = previousNode;\n                partIndex++;\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\n/**\n * Returns a value ready to be inserted into a Part from a user-provided value.\n *\n * If the user value is a directive, this invokes the directive with the given\n * part. If the value is null, it's converted to undefined to work better\n * with certain DOM APIs, like textContent.\n */\nexport const getValue = (part, value) => {\n    // `null` as the value of a Text node will render the string 'null'\n    // so we convert it to undefined\n    if (isDirective(value)) {\n        value = value(part);\n        return directiveValue;\n    }\n    return value === null ? undefined : value;\n};\nexport const directive = (f) => {\n    f.__litDirective = true;\n    return f;\n};\nconst isDirective = (o) => typeof o === 'function' && o.__litDirective === true;\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const directiveValue = {};\nconst isPrimitiveValue = (value) => value === null ||\n    !(typeof value === 'object' || typeof value === 'function');\nexport class AttributePart {\n    constructor(instance, element, name, strings) {\n        this.instance = instance;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.size = strings.length - 1;\n        this._previousValues = [];\n    }\n    _interpolate(values, startIndex) {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const v = getValue(this, values[startIndex + i]);\n            if (v && v !== directiveValue &&\n                (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                for (const t of v) {\n                    // TODO: we need to recursively call getValue into iterables...\n                    text += t;\n                }\n            }\n            else {\n                text += v;\n            }\n        }\n        return text + strings[l];\n    }\n    _equalToPreviousValues(values, startIndex) {\n        for (let i = startIndex; i < startIndex + this.size; i++) {\n            if (this._previousValues[i] !== values[i] ||\n                !isPrimitiveValue(values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    setValue(values, startIndex) {\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        const s = this.strings;\n        let value;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n            if (Array.isArray(value)) {\n                value = value.join('');\n            }\n        }\n        else {\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== directiveValue) {\n            this.element.setAttribute(this.name, value);\n        }\n        this._previousValues = values;\n    }\n}\nexport class NodePart {\n    constructor(instance, startNode, endNode) {\n        this.instance = instance;\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this._previousValue = undefined;\n    }\n    setValue(value) {\n        value = getValue(this, value);\n        if (value === directiveValue) {\n            return;\n        }\n        if (isPrimitiveValue(value)) {\n            // Handle primitive values\n            // If the value didn't change, do nothing\n            if (value === this._previousValue) {\n                return;\n            }\n            this._setText(value);\n        }\n        else if (value instanceof TemplateResult) {\n            this._setTemplateResult(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._setIterable(value);\n        }\n        else if (value instanceof Node) {\n            this._setNode(value);\n        }\n        else if (value.then !== undefined) {\n            this._setPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._setText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _setNode(value) {\n        if (this._previousValue === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this._previousValue = value;\n    }\n    _setText(value) {\n        const node = this.startNode.nextSibling;\n        value = value === undefined ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if _previousValue is\n            // primitive?\n            node.textContent = value;\n        }\n        else {\n            this._setNode(document.createTextNode(value));\n        }\n        this._previousValue = value;\n    }\n    _setTemplateResult(value) {\n        const template = this.instance._getTemplate(value);\n        let instance;\n        if (this._previousValue && this._previousValue.template === template) {\n            instance = this._previousValue;\n        }\n        else {\n            instance = new TemplateInstance(template, this.instance._partCallback, this.instance._getTemplate);\n            this._setNode(instance._clone());\n            this._previousValue = instance;\n        }\n        instance.update(value.values);\n    }\n    _setIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _previousValue is an array, then the previous render was of an\n        // iterable and _previousValue will contain the NodeParts from the previous\n        // render. If _previousValue is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this._previousValue)) {\n            this.clear();\n            this._previousValue = [];\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._previousValue;\n        let partIndex = 0;\n        for (const item of value) {\n            // Try to reuse an existing part\n            let itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                // If we're creating the first item part, it's startNode should be the\n                // container's startNode\n                let itemStart = this.startNode;\n                // If we're not creating the first part, create a new separator marker\n                // node, and fix up the previous part's endNode to point to it\n                if (partIndex > 0) {\n                    const previousPart = itemParts[partIndex - 1];\n                    itemStart = previousPart.endNode = document.createTextNode('');\n                    this._insert(itemStart);\n                }\n                itemPart = new NodePart(this.instance, itemStart, this.endNode);\n                itemParts.push(itemPart);\n            }\n            itemPart.setValue(item);\n            partIndex++;\n        }\n        if (partIndex === 0) {\n            this.clear();\n            this._previousValue = undefined;\n        }\n        else if (partIndex < itemParts.length) {\n            const lastPart = itemParts[partIndex - 1];\n            // Truncate the parts array so _previousValue reflects the current state\n            itemParts.length = partIndex;\n            this.clear(lastPart.endNode.previousSibling);\n            lastPart.endNode = this.endNode;\n        }\n    }\n    _setPromise(value) {\n        this._previousValue = value;\n        value.then((v) => {\n            if (this._previousValue === value) {\n                this.setValue(v);\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\nexport const defaultPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        return new AttributePart(instance, node, templatePart.name, templatePart.strings);\n    }\n    else if (templatePart.type === 'node') {\n        return new NodePart(instance, node, node.nextSibling);\n    }\n    throw new Error(`Unknown part type ${templatePart.type}`);\n};\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, partCallback, getTemplate) {\n        this._parts = [];\n        this.template = template;\n        this._partCallback = partCallback;\n        this._getTemplate = getTemplate;\n    }\n    update(values) {\n        let valueIndex = 0;\n        for (const part of this._parts) {\n            if (part.size === undefined) {\n                part.setValue(values[valueIndex]);\n                valueIndex++;\n            }\n            else {\n                part.setValue(values, valueIndex);\n                valueIndex += part.size;\n            }\n        }\n    }\n    _clone() {\n        const fragment = document.importNode(this.template.element.content, true);\n        const parts = this.template.parts;\n        if (parts.length > 0) {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                   NodeFilter.SHOW_TEXT */, null, false);\n            let index = -1;\n            for (let i = 0; i < parts.length; i++) {\n                const part = parts[i];\n                while (index < part.index) {\n                    index++;\n                    walker.nextNode();\n                }\n                this._parts.push(this._partCallback(this, part, walker.currentNode));\n            }\n        }\n        return fragment;\n    }\n}\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, defaultPartCallback, directiveValue, getValue, SVGTemplateResult, TemplateResult } from '../lit-html.js';\nexport { render } from '../lit-html.js';\n/**\n * Interprets a template literal as a lit-extended HTML template.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', extendedPartCallback);\n/**\n * Interprets a template literal as a lit-extended SVG template.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', extendedPartCallback);\n/**\n * A PartCallback which allows templates to set properties and declarative\n * event handlers.\n *\n * Properties are set by default, instead of attributes. Attribute names in\n * lit-html templates preserve case, so properties are case sensitive. If an\n * expression takes up an entire attribute value, then the property is set to\n * that value. If an expression is interpolated with a string or other\n * expressions then the property is set to the string result of the\n * interpolation.\n *\n * To set an attribute instead of a property, append a `$` suffix to the\n * attribute name.\n *\n * Example:\n *\n *     html`<button class$=\"primary\">Buy Now</button>`\n *\n * To set an event handler, prefix the attribute name with `on-`:\n *\n * Example:\n *\n *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`\n *\n */\nexport const extendedPartCallback = (instance, templatePart, node) => {\n    if (templatePart.type === 'attribute') {\n        if (templatePart.rawName.startsWith('on-')) {\n            const eventName = templatePart.rawName.slice(3);\n            return new EventPart(instance, node, eventName);\n        }\n        if (templatePart.name.endsWith('$')) {\n            const name = templatePart.name.slice(0, -1);\n            return new AttributePart(instance, node, name, templatePart.strings);\n        }\n        if (templatePart.name.endsWith('?')) {\n            const name = templatePart.name.slice(0, -1);\n            return new BooleanAttributePart(instance, node, name, templatePart.strings);\n        }\n        return new PropertyPart(instance, node, templatePart.rawName, templatePart.strings);\n    }\n    return defaultPartCallback(instance, templatePart, node);\n};\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            const value = getValue(this, values[startIndex]);\n            if (value === directiveValue) {\n                return;\n            }\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        else {\n            throw new Error('boolean attributes can only contain a single expression');\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n    setValue(values, startIndex) {\n        const s = this.strings;\n        let value;\n        if (this._equalToPreviousValues(values, startIndex)) {\n            return;\n        }\n        if (s.length === 2 && s[0] === '' && s[1] === '') {\n            // An expression that occupies the whole attribute value will leave\n            // leading and trailing empty strings.\n            value = getValue(this, values[startIndex]);\n        }\n        else {\n            // Interpolation, so interpolate\n            value = this._interpolate(values, startIndex);\n        }\n        if (value !== directiveValue) {\n            this.element[this.name] = value;\n        }\n        this._previousValues = values;\n    }\n}\nexport class EventPart {\n    constructor(instance, element, eventName) {\n        this.instance = instance;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        const listener = getValue(this, value);\n        const previous = this._listener;\n        if (listener === previous) {\n            return;\n        }\n        this._listener = listener;\n        if (previous != null) {\n            this.element.removeEventListener(this.eventName, previous);\n        }\n        if (listener != null) {\n            this.element.addEventListener(this.eventName, listener);\n        }\n    }\n}\n//# sourceMappingURL=lit-extended.js.map","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n */\nfunction MixinFunction(){}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nexport const dedupingMixin = function(mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */(mixin)(base);\n      map.set(base, extended);\n    }\n    // copy inherited mixin set from the extended class, or the base class\n    // NOTE: we avoid use of Set here because some browser (IE11)\n    // cannot extend a base Set via the constructor.\n    let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);\n    mixinSet[mixinDedupeId] = true;\n    /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;\n    return extended;\n  }\n\n  return /** @type {T} */ (dedupingMixin);\n};\n/* eslint-enable valid-jsdoc */\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\nimport './boot.js';\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\nfunction microtaskFlush() {\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => { throw e; });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) { return window.setTimeout(fn, delay); },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\nexport {timeOut};\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\nexport {animationFrame};\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ?\n      window.requestIdleCallback(fn) :\n      window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ?\n      window.cancelIdleCallback(handle) :\n      window.clearTimeout(handle);\n  }\n};\nexport {idlePeriod};\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    microtaskNode.textContent = microtaskNodeContent++;\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nexport {microTask};\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\n\n/** @const {!AsyncInterface} */\nconst microtask = microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n */\nexport const PropertiesChanged = dedupingMixin(superClass => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {superClass}\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     */\n    static typeForProperty(name) { } //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty('__dataHasAccessor')) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty('__dataAttributes')) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      if (!this.__dataAttributes[property]) {\n        const attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     */\n     _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          return this._getProperty(property);\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          this._setProperty(property, value);\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     */\n    _flushProperties() {\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {!Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {!Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {!Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {!Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        (old !== value &&\n          // This ensures (old==NaN, value==NaN) always returns false\n          (old === old || value === value))\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type ||\n          this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = (arguments.length < 3) ? this[property] : value;\n      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,\n        attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute, str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return (value !== null);\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { PropertiesChanged } from './properties-changed.js';\n\n/**\n * Creates a copy of `props` with each property normalized such that\n * upgraded it is an object with at least a type property { type: Type}.\n *\n * @param {Object} props Properties to normalize\n * @return {Object} Copy of input `props` with normalized properties that\n * are in the form {type: Type}\n * @private\n */\nfunction normalizeProperties(props) {\n  const output = {};\n  for (let p in props) {\n    const o = props[p];\n    output[p] = (typeof o === 'function') ? {type: o} : o;\n  }\n  return output;\n}\n\n/**\n * Mixin that provides a minimal starting point to using the PropertiesChanged\n * mixin by providing a mechanism to declare properties in a static\n * getter (e.g. static get properties() { return { foo: String } }). Changes\n * are reported via the `_propertiesChanged` method.\n *\n * This mixin provides no specific support for rendering. Users are expected\n * to create a ShadowRoot and put content into it and update it in whatever\n * way makes sense. This can be done in reaction to properties changing by\n * implementing `_propertiesChanged`.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Mixin that provides a minimal starting point for using\n * the PropertiesChanged mixin by providing a declarative `properties` object.\n */\nexport const PropertiesMixin = dedupingMixin(superClass => {\n\n /**\n  * @constructor\n  * @extends {superClass}\n  * @implements {Polymer_PropertiesChanged}\n  */\n const base = PropertiesChanged(superClass);\n\n /**\n  * Returns the super class constructor for the given class, if it is an\n  * instance of the PropertiesMixin.\n  *\n  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n  * @return {PropertiesMixinConstructor} Super class constructor\n  */\n function superPropertiesClass(constructor) {\n   const superCtor = Object.getPrototypeOf(constructor);\n\n   // Note, the `PropertiesMixin` class below only refers to the class\n   // generated by this call to the mixin; the instanceof test only works\n   // because the mixin is deduped and guaranteed only to apply once, hence\n   // all constructors in a proto chain will see the same `PropertiesMixin`\n   return (superCtor.prototype instanceof PropertiesMixin) ?\n     /** @type {PropertiesMixinConstructor} */ (superCtor) : null;\n }\n\n /**\n  * Returns a memoized version of the `properties` object for the\n  * given class. Properties not in object format are converted to at\n  * least {type}.\n  *\n  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n  * @return {Object} Memoized properties object\n  */\n function ownProperties(constructor) {\n   if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n     let props = null;\n\n     if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor)) && constructor.properties) {\n       props = normalizeProperties(constructor.properties);\n     }\n\n     constructor.__ownProperties = props;\n   }\n   return constructor.__ownProperties;\n }\n\n /**\n  * @polymer\n  * @mixinClass\n  * @extends {base}\n  * @implements {Polymer_PropertiesMixin}\n  * @unrestricted\n  */\n class PropertiesMixin extends base {\n\n   /**\n    * Implements standard custom elements getter to observes the attributes\n    * listed in `properties`.\n    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n    */\n   static get observedAttributes() {\n     const props = this._properties;\n     return props ? Object.keys(props).map(p => this.attributeNameForProperty(p)) : [];\n   }\n\n   /**\n    * Finalizes an element definition, including ensuring any super classes\n    * are also finalized. This includes ensuring property\n    * accessors exist on the element prototype. This method calls\n    * `_finalizeClass` to finalize each constructor in the prototype chain.\n    * @return {void}\n    */\n   static finalize() {\n     if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n       const superCtor = superPropertiesClass(/** @type {PropertiesMixinConstructor} */(this));\n       if (superCtor) {\n         superCtor.finalize();\n       }\n       this.__finalized = true;\n       this._finalizeClass();\n     }\n   }\n\n   /**\n    * Finalize an element class. This includes ensuring property\n    * accessors exist on the element prototype. This method is called by\n    * `finalize` and finalizes the class constructor.\n    *\n    * @protected\n    */\n   static _finalizeClass() {\n     const props = ownProperties(/** @type {PropertiesMixinConstructor} */(this));\n     if (props) {\n       this.createProperties(props);\n     }\n   }\n\n   /**\n    * Returns a memoized version of all properties, including those inherited\n    * from super classes. Properties not in object format are converted to\n    * at least {type}.\n    *\n    * @return {Object} Object containing properties for this class\n    * @protected\n    */\n   static get _properties() {\n     if (!this.hasOwnProperty(\n       JSCompiler_renameProperty('__properties', this))) {\n       const superCtor = superPropertiesClass(/** @type {PropertiesMixinConstructor} */(this));\n       this.__properties = Object.assign({},\n         superCtor && superCtor._properties,\n         ownProperties(/** @type {PropertiesMixinConstructor} */(this)));\n     }\n     return this.__properties;\n   }\n\n   /**\n    * Overrides `PropertiesChanged` method to return type specified in the\n    * static `properties` object for the given property.\n    * @param {string} name Name of property\n    * @return {*} Type to which to deserialize attribute\n    *\n    * @protected\n    */\n   static typeForProperty(name) {\n     const info = this._properties[name];\n     return info && info.type;\n   }\n\n   /**\n    * Overrides `PropertiesChanged` method and adds a call to\n    * `finalize` which lazily configures the element's property accessors.\n    * @override\n    * @return {void}\n    */\n   _initializeProperties() {\n     this.constructor.finalize();\n     super._initializeProperties();\n   }\n\n   /**\n    * Called when the element is added to a document.\n    * Calls `_enableProperties` to turn on property system from\n    * `PropertiesChanged`.\n    * @suppress {missingProperties} Super may or may not implement the callback\n    * @return {void}\n    */\n   connectedCallback() {\n     if (super.connectedCallback) {\n       super.connectedCallback();\n     }\n     this._enableProperties();\n   }\n\n   /**\n    * Called when the element is removed from a document\n    * @suppress {missingProperties} Super may or may not implement the callback\n    * @return {void}\n    */\n   disconnectedCallback() {\n     if (super.disconnectedCallback) {\n       super.disconnectedCallback();\n     }\n   }\n\n }\n\n return PropertiesMixin;\n\n});\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { render as baseRender, Template, templateCaches } from '../lit-html.js';\nexport { html, svg, TemplateResult } from '../lit-html.js';\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = `${result.type}--${scopeName}`;\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (typeof window.ShadyCSS === 'object') {\n            window.ShadyCSS.prepareTemplate(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.set(result.strings, template);\n    }\n    return template;\n};\nexport function render(result, container, scopeName) {\n    return baseRender(result, container, shadyTemplateFactory(scopeName));\n}\n//# sourceMappingURL=shady-render.js.map","import { PropertiesMixin } from '@polymer/polymer/lib/mixins/properties-mixin.js';\nimport { camelToDashCase } from '@polymer/polymer/lib/utils/case-map.js';\nimport { render } from 'lit-html/lib/shady-render.js';\nexport { html } from 'lit-html/lib/lit-extended.js';\n/**\n * Renders attributes to the given element based on the `attrInfo` object where\n * boolean values are added/removed as attributes.\n * @param element Element on which to set attributes.\n * @param attrInfo Object describing attributes.\n */\nexport function renderAttributes(element, attrInfo) {\n    for (const a in attrInfo) {\n        const v = attrInfo[a] === true ? '' : attrInfo[a];\n        if (v || v === '' || v === 0) {\n            if (element.getAttribute(a) !== v) {\n                element.setAttribute(a, v);\n            }\n        }\n        else if (element.hasAttribute(a)) {\n            element.removeAttribute(a);\n        }\n    }\n}\n/**\n * Returns a string of css class names formed by taking the properties\n * in the `classInfo` object and appending the property name to the string of\n * class names if the property value is truthy.\n * @param classInfo\n */\nexport function classString(classInfo) {\n    const o = [];\n    for (const name in classInfo) {\n        const v = classInfo[name];\n        if (v) {\n            o.push(name);\n        }\n    }\n    return o.join(' ');\n}\n/**\n * Returns a css style string formed by taking the properties in the `styleInfo`\n * object and appending the property name (dash-cased) colon the\n * property value. Properties are separated by a semi-colon.\n * @param styleInfo\n */\nexport function styleString(styleInfo) {\n    const o = [];\n    for (const name in styleInfo) {\n        const v = styleInfo[name];\n        if (v || v === 0) {\n            o.push(`${camelToDashCase(name)}: ${v}`);\n        }\n    }\n    return o.join('; ');\n}\nexport class LitElement extends PropertiesMixin(HTMLElement) {\n    constructor() {\n        super(...arguments);\n        this.__renderComplete = null;\n        this.__resolveRenderComplete = null;\n        this.__isInvalid = false;\n        this.__isChanging = false;\n    }\n    /**\n     * Override which sets up element rendering by calling* `_createRoot`\n     * and `_firstRendered`.\n     */\n    ready() {\n        this._root = this._createRoot();\n        super.ready();\n        this._firstRendered();\n    }\n    /**\n     * Called after the element DOM is rendered for the first time.\n     * Implement to perform tasks after first rendering like capturing a\n     * reference to a static node which must be directly manipulated.\n     * This should not be commonly needed. For tasks which should be performed\n     * before first render, use the element constructor.\n     */\n    _firstRendered() { }\n    /**\n     * Implement to customize where the element's template is rendered by\n     * returning an element into which to render. By default this creates\n     * a shadowRoot for the element. To render into the element's childNodes,\n     * return `this`.\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\n     */\n    _createRoot() {\n        return this.attachShadow({ mode: 'open' });\n    }\n    /**\n     * Override which returns the value of `_shouldRender` which users\n     * should implement to control rendering. If this method returns false,\n     * _propertiesChanged will not be called and no rendering will occur even\n     * if property values change or `_requestRender` is called.\n     * @param _props Current element properties\n     * @param _changedProps Changing element properties\n     * @param _prevProps Previous element properties\n     * @returns {boolean} Default implementation always returns true.\n     */\n    _shouldPropertiesChange(_props, _changedProps, _prevProps) {\n        const shouldRender = this._shouldRender(_props, _changedProps, _prevProps);\n        if (!shouldRender && this.__resolveRenderComplete) {\n            this.__resolveRenderComplete(false);\n        }\n        return shouldRender;\n    }\n    /**\n     * Implement to control if rendering should occur when property values\n     * change or `_requestRender` is called. By default, this method always returns\n     * true, but this can be customized as an optimization to avoid rendering work\n     * when changes occur which should not be rendered.\n     * @param _props Current element properties\n     * @param _changedProps Changing element properties\n     * @param _prevProps Previous element properties\n     * @returns {boolean} Default implementation always returns true.\n     */\n    _shouldRender(_props, _changedProps, _prevProps) {\n        return true;\n    }\n    /**\n     * Override which performs element rendering by calling\n     * `_render`, `_applyRender`, and finally `_didRender`.\n     * @param props Current element properties\n     * @param changedProps Changing element properties\n     * @param prevProps Previous element properties\n     */\n    _propertiesChanged(props, changedProps, prevProps) {\n        super._propertiesChanged(props, changedProps, prevProps);\n        const result = this._render(props);\n        if (result && this._root !== undefined) {\n            this._applyRender(result, this._root);\n        }\n        this._didRender(props, changedProps, prevProps);\n        if (this.__resolveRenderComplete) {\n            this.__resolveRenderComplete(true);\n        }\n    }\n    _flushProperties() {\n        this.__isChanging = true;\n        this.__isInvalid = false;\n        super._flushProperties();\n        this.__isChanging = false;\n    }\n    /**\n     * Override which warns when a user attempts to change a property during\n     * the rendering lifecycle. This is an anti-pattern and should be avoided.\n     * @param property {string}\n     * @param value {any}\n     * @param old {any}\n     */\n    _shouldPropertyChange(property, value, old) {\n        const change = super._shouldPropertyChange(property, value, old);\n        if (change && this.__isChanging) {\n            console.trace(`Setting properties in response to other properties changing ` +\n                `considered harmful. Setting '${property}' from ` +\n                `'${this._getProperty(property)}' to '${value}'.`);\n        }\n        return change;\n    }\n    /**\n     * Implement to describe the DOM which should be rendered in the element.\n     * Ideally, the implementation is a pure function using only props to describe\n     * the element template. The implementation must a `lit-html` TemplateResult.\n     * By default this template is rendered into the element's shadowRoot.\n     * This can be customized by implementing `_createRoot`. This method must be\n     * implemented.\n     * @param {*} _props Current element properties\n     * @returns {TemplateResult} Must return a lit-html TemplateResult.\n     */\n    _render(_props) {\n        throw new Error('render() not implemented');\n    }\n    /**\n     * Renders the given lit-html template `result` into the given `node`.\n     * Implement to customize the way rendering is applied. This is should not\n     * typically be needed and is provided for advanced use cases.\n     * @param result {TemplateResult} `lit-html` template result to render\n     * @param node {Element|DocumentFragment} node into which to render\n     */\n    _applyRender(result, node) {\n        render(result, node, this.localName);\n    }\n    /**\n     * Called after element DOM has been rendered. Implement to\n     * directly control rendered DOM. Typically this is not needed as `lit-html`\n     * can be used in the `_render` method to set properties, attributes, and\n     * event listeners. However, it is sometimes useful for calling methods on\n     * rendered elements, like calling `focus()` on an element to focus it.\n     * @param _props Current element properties\n     * @param _changedProps Changing element properties\n     * @param _prevProps Previous element properties\n     */\n    _didRender(_props, _changedProps, _prevProps) { }\n    /**\n     * Call to request the element to asynchronously re-render regardless\n     * of whether or not any property changes are pending.\n     */\n    _requestRender() { this._invalidateProperties(); }\n    /**\n     * Override which provides tracking of invalidated state.\n     */\n    _invalidateProperties() {\n        this.__isInvalid = true;\n        super._invalidateProperties();\n    }\n    /**\n     * Returns a promise which resolves after the element next renders.\n     * The promise resolves to `true` if the element rendered and `false` if the\n     * element did not render.\n     * This is useful when users (e.g. tests) need to react to the rendered state\n     * of the element after a change is made.\n     * This can also be useful in event handlers if it is desireable to wait\n     * to send an event until after rendering. If possible implement the\n     * `_didRender` method to directly respond to rendering within the\n     * rendering lifecycle.\n     */\n    get renderComplete() {\n        if (!this.__renderComplete) {\n            this.__renderComplete = new Promise((resolve) => {\n                this.__resolveRenderComplete =\n                    (value) => {\n                        this.__resolveRenderComplete = this.__renderComplete = null;\n                        resolve(value);\n                    };\n            });\n            if (!this.__isInvalid && this.__resolveRenderComplete) {\n                Promise.resolve().then(() => this.__resolveRenderComplete(false));\n            }\n        }\n        return this.__renderComplete;\n    }\n}\n//# sourceMappingURL=lit-element.js.map","'use strict';\n\nimport { LitElement, html } from '@polymer/lit-element';\n\nclass TabContent extends LitElement {\n\n  static get is() { return 'tab-content'; }\n\n  static get properties() { return { visible: Boolean }; }  \n  \n  _render({ visible }){\n    return html`\n      ${visible ? html`<slot></slot>` : ''}\n    `;\n  }\n}\n\ncustomElements.define(TabContent.is, TabContent);","'use strict';\n\nimport { html } from 'lit-html/lib/lit-extended';\nimport { LitElement } from '@polymer/lit-element';\nimport './../tab-content/';\n\nclass TabsMain extends LitElement {\n\n    static get is() { return 'tabs-main'; }\n\n    static get properties() { return {\n        labels: Array,\n        pills: Boolean,\n        vertical: Boolean,\n        centered: Boolean,\n        fullWidth:Boolean,\n        active: Number,\n    } }\n\n    constructor() {\n      super();\n\n      this.labels = [];\n      this.pills = false;\n      this.vertical = false;\n      this.centered = false;\n      this.fullWidth = false;\n      this.active = 0;\n    }\n\n    _activateThis(evt) {\n      evt ? evt.preventDefault() : null;\n      this.active = parseInt(evt.currentTarget.dataset.index);\n      this._setActive(this.active);\n    }\n\n    _setActive(index){\n      const tabs = this.querySelectorAll('tab-content');\n      tabs.forEach((e,i) => {\n        i === index ? e.visible = true : e.visible = false;\n      });\n      this.dispatchEvent(new CustomEvent('change', {\n        bubbles: true,\n        composed: true,\n        detail: {\n          active: index\n        }\n      }));\n    }\n\n    _computeType(pills, vertical, centered, fullWidth) {\n      const arr = pills ? ['pills'] : ['tabs'];\n      vertical ? arr.push('vertical') : null;\n      centered ? arr.push('centered') : null;\n      fullWidth ? arr.push('full-width') : null;\n      return arr.join(' ');\n    }\n\n    _computeActive(active, index) {\n      return (active === index) ? 'tab active' : 'tab';\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this._setActive(this.active);\n    }\n\n    _render({ \n      pills, vertical, centered, fullWidth, labels, active\n    }){\n      const _labels = JSON.parse(labels) || [];\n\n      return html`\n        <div class$=\"${this._computeType(pills, vertical, centered, fullWidth)}\">\n          <ul>\n            ${_labels ? _labels.map((e,i) => html`\n              <li\n                class$=\"${this._computeActive(active, i)}\"\n              ><a \n                href=\"#\" \n                data-index$=\"${i}\"\n                on-click=\"${(evt) => this._activateThis(evt)}\"\n              >${e}</a></li>\n            `) : ''}\n          </ul>\n          <slot></slot>\n        </div>\n      `;\n    }\n}\n\ncustomElements.define(TabsMain.is, TabsMain );"],"sourceRoot":""}